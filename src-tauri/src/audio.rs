use std::io::Cursor;
use std::time::Duration;

/// Embedded chime WAV file (generated by scripts/generate-chime.mjs).
const CHIME_WAV: &[u8] = include_bytes!("../../public/sounds/chime.wav");

/// Play the alarm chime sequence in a background thread.
/// Plays the chime `repetitions` times with 1-second gaps.
/// Returns immediately â€” audio plays asynchronously.
#[allow(clippy::needless_pass_by_value)]
#[tauri::command]
pub fn play_alarm(volume: f32, repetitions: u32) -> Result<(), String> {
    let vol = volume.clamp(0.0, 1.0);
    let reps = repetitions.clamp(1, 5);

    std::thread::spawn(move || {
        if let Err(e) = play_chime_sequence(vol, reps) {
            eprintln!("Alarm playback error: {e}");
        }
    });

    Ok(())
}

fn play_chime_sequence(volume: f32, repetitions: u32) -> Result<(), String> {
    let (_stream, handle) =
        rodio::OutputStream::try_default().map_err(|e| format!("No audio output device: {e}"))?;

    for i in 0..repetitions {
        let cursor = Cursor::new(CHIME_WAV);
        let source = rodio::Decoder::new(cursor)
            .map_err(|e| format!("Failed to decode chime: {e}"))?;
        let sink = rodio::Sink::try_new(&handle)
            .map_err(|e| format!("Failed to create audio sink: {e}"))?;
        sink.set_volume(volume);
        sink.append(source);
        sink.sleep_until_end();

        if i < repetitions - 1 {
            std::thread::sleep(Duration::from_secs(1));
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn chime_wav_is_valid() {
        // Verify the embedded WAV starts with RIFF header
        assert!(CHIME_WAV.len() > 44, "WAV file too small");
        assert_eq!(&CHIME_WAV[0..4], b"RIFF");
        assert_eq!(&CHIME_WAV[8..12], b"WAVE");
    }

    #[test]
    fn volume_is_clamped() {
        // Just verify the function doesn't panic with edge values
        // Actual audio playback not tested (requires audio device)
        let result = play_alarm(1.5, 1);
        // May fail in CI without audio device, which is OK
        assert!(result.is_ok());
    }
}
